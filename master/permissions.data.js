window.source = {
  "url": "permissions.html",
  "type": "js",
  "content": "import PermissionCache from './permissions__cache';\n\n/**\n * <code>\n *   const permissions = new Permissions(auth, {prefix: 'jetbrains.jetpass.', services: [auth.serviceId]})\n *   permissions.load().then(function (p) {\n *     const canReadUser = p.has('read-user');\n *     ...\n *   });\n *\n *   permissions.check('read-user').then(function(canReadUser) {\n *     ...\n *   });\n * </code>\n *\n * @param {Auth} auth instance of well configured Auth object\n * @param {{\n *   prefix: string?,\n *   namesConverter: function?\n *   serviceId: string?\n * }=} config permissions loaded configuration.\n * <code>prefix</code> if provided then this prefix is removed from the permissions names.\n * <code>namesConverter</code> if provided it maps permission names used on server-side to client-side permission names. It is used only if prefix is undefined.\n * <code>serviceId</code> if provided then permissions only for the service are loaded.\n * @constructor\n */\nexport default class Permissions {\n  /**\n   * @const {string}\n   */\n  static API_PERMISSION_CACHE_PATH = 'permissions/cache';\n\n  constructor(auth, config = {}) {\n    this.query = Permissions.getPermissionQuery(config.services);\n    this.namesConverter = config.prefix\n      ? Permissions.getDefaultNamesConverter(config.prefix)\n      : config.namesConverter;\n\n    if (!auth) {\n      throw new Error('Parameter auth is required');\n    }\n\n    this._auth = auth;\n    this._datasource = config.datasource || this._defaultDatasource;\n    this._promise = null;\n    this._subscribed = false;\n    this._permissionCache = new PermissionCache(null, this.namesConverter);\n  }\n\n  _defaultDatasource = query => (\n    this._auth.http.get(Permissions.API_PERMISSION_CACHE_PATH, {\n      query: {\n        fields: 'permission/key,global,projects(id)',\n        query\n      }\n    })\n  )\n\n  /**\n   * Returns function, which cuts off prefix from server-side permission name\n   *\n   * @param {string} prefix\n   * @returns {Function}\n   */\n  static getDefaultNamesConverter(prefix) {\n    return storedName => {\n      if (storedName.indexOf(prefix) !== 0) {\n        return storedName;\n      } else {\n        return storedName.substr(prefix.length);\n      }\n    };\n  }\n\n  static getPermissionQuery(services) {\n    if (!services || !services.length) {\n      return undefined;\n    }\n    return services.map(service => `service:{${service}}`).join(' or ');\n  }\n\n  set(cachedPermissions) {\n    this._permissionCache.set(cachedPermissions);\n    this._setCache(Promise.resolve(this._permissionCache));\n    return this._permissionCache;\n  }\n\n  get() {\n    return this._permissionCache.get();\n  }\n\n  _setCache(value) {\n    this._promise = value;\n    return value;\n  }\n\n  _getCache() {\n    return this._promise;\n  }\n\n  _resetCache() {\n    this._setCache(null);\n  }\n\n  /**\n   * Loads logged-in user permissions.\n   * @param {object?} options\n   * @return {Promise.<Permissions>} promise that is resolved when the permissions are loaded\n   */\n  load(options) {\n    if (this._subscribed === false) {\n      this._auth.addListener('userChange', () => {\n        this.reload();\n      });\n      this._subscribed = true;\n    }\n\n    if (!hasCacheControl('NO_CACHE', options) && this._getCache()) {\n      return this._getCache();\n    }\n\n    if (hasCacheControl('NO_STORE', options)) {\n      return this._loadPermissions().\n        then(cachedPermissions => new PermissionCache(cachedPermissions, this.namesConverter));\n    }\n\n    return this._setCache(\n      this._loadPermissions().\n        then(cachedPermissions => this.set(cachedPermissions))\n    );\n\n    function hasCacheControl(value, _options) {\n      if (_options && _options.cacheControl) {\n        return _options.cacheControl[value];\n      }\n      return false;\n    }\n  }\n\n  _loadPermissions() {\n    return this._datasource(this.query);\n  }\n\n  /**\n   * Reloads permission cache from server\n   * @returns {Promise.<Permissions>} promise that is resolved when the permissions are reloaded\n   */\n  reload() {\n    this._resetCache();\n    return this.load();\n  }\n\n  /**\n   * Waits till the permission cache is loaded then checks if the current user has the\n   * given permissions in the project with the given id.\n   *\n   * @param {string} permissions  space separated list of permissions\n   * @param {string=} projectId     optional projectId. If absent the method checks\n   *  if the given permission is granted in any project.\n   *\n   * @return {Promise.<boolean>}\n   */\n  check(permissions, projectId) {\n    return this.load().then(permissionCache => permissionCache.has(permissions, projectId));\n  }\n\n  /**\n   * Binds a property with the name <code>propertyName</code> of the <code>object</code>\n   * to a boolean value that is true if user has the permissions and false if she doesn't.\n   *\n   * @example\n   * <code>\n   *   userPermissions.bindVariable($scope, 'canReadRole', 'role-read')\n   * </code>\n   *\n   * @param {object} object       an object which property should be bound\n   * @param {string} propertyName a name of a property to bind\n   * @param {string} permissions  space separated list of permissions\n   * @param {string=} projectId     optional projectId. If absent the method checks\n   *  if the given permissions are granted in any project.\n   *\n   * @return {Promise.<boolean>}\n   */\n  bindVariable(object, propertyName, permissions, projectId) {\n    object[propertyName] = false;\n\n    return this.check(permissions, projectId).\n      then(permitted => {\n        object[propertyName] = permitted;\n        return permitted;\n      });\n  }\n}\n",
  "examples": [
    {
      "url": "examples/permissions/6b7354fe460de8c143d212bf4a43a2b7.html",
      "disableAutoSize": false,
      "files": []
    }
  ],
  "attrs": {
    "param": "{{\n  prefix: string?,\n  namesConverter: function?\n  serviceId: string?\n}=} config permissions loaded configuration.\n<code>prefix</code> if provided then this prefix is removed from the permissions names.\n<code>namesConverter</code> if provided it maps permission names used on server-side to client-side permission names. It is used only if prefix is undefined.\n<code>serviceId</code> if provided then permissions only for the service are loaded.",
    "constructor": ""
  }
};